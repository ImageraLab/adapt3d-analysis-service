from fastapi import FastAPI, HTTPException from pydantic import BaseModel import cv2 import numpy as np from PIL import Image import io import requests import h5py import tempfile import os from skimage import filters, morphology, measure import time import logging
# Configure logging logging.basicConfig(level=logging.INFO) logger = logging.getLogger(__name__)
# Increase PIL image size limit Image.MAX_IMAGE_PIXELS = 200000000
app = FastAPI(title="ADAPT-3D Vessel Analysis Service", version="1.0.0")
class AnalysisRequest(BaseModel):     image_url: str     metadata: dict
def download_file(url: str, max_retries: int = 3):     """Download file from URL and save to temp location."""     logger.info(f"Downloading file from: {url}")          for attempt in range(max_retries):         try:             response = requests.get(url, timeout=180, stream=True)             response.raise_for_status()                          # Save to temporary file             temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.ims')                          # Download in chunks             for chunk in response.iter_content(chunk_size=8192):                 if chunk:                     temp_file.write(chunk)                          temp_file.close()             logger.info(f"File downloaded successfully to: {temp_file.name}")             return temp_file.name                      except Exception as e:             logger.error(f"Download attempt {attempt + 1} failed: {str(e)}")             if attempt < max_retries - 1:                 time.sleep(2 ** attempt)                 continue             raise HTTPException(status_code=400, detail=f"Failed to download file: {str(e)}")          raise HTTPException(status_code=500, detail="Failed to download file")
def is_ims_file(filepath: str) -> bool:     """Check if file is an Imaris .ims file."""     try:         with h5py.File(filepath, 'r') as f:             # Check for Imaris-specific structure             return 'DataSet' in f or 'DataSetInfo' in f     except:         return False
def extract_ims_metadata(filepath: str) -> dict:     """Extract metadata from .ims file."""     try:         with h5py.File(filepath, 'r') as f:             metadata = {}                          # Try to get basic information             if 'DataSetInfo' in f:                 info = f['DataSetInfo']                 if 'Image' in info.attrs:                     metadata['image_info'] = str(info.attrs['Image'])                          # Get dataset dimensions             if 'DataSet' in f:                 dataset = f['DataSet']                 if 'ResolutionLevel 0' in dataset:                     res_level = dataset['ResolutionLevel 0']                     if 'TimePoint 0' in res_level:                         timepoint = res_level['TimePoint 0']                         if 'Channel 0' in timepoint:                             channel = timepoint['Channel 0']                             if 'Data' in channel:                                 data = channel['Data']                                 metadata['dimensions'] = {                                     'shape': data.shape,                                     'dtype': str(data.dtype)                                 }                          logger.info(f"Extracted metadata: {metadata}")             return metadata     except Exception as e:         logger.error(f"Failed to extract metadata: {str(e)}")         return {}
def extract_slice_from_ims(filepath: str, slice_index: int = None) -> np.ndarray:     """Extract a 2D slice from .ims file for analysis."""     try:         with h5py.File(filepath, 'r') as f:             # Navigate to data             dataset = f['DataSet']['ResolutionLevel 0']['TimePoint 0']['Channel 0']['Data']                          # Get middle slice if not specified             if slice_index is None:                 slice_index = dataset.shape[0] // 2                          # Extract slice             slice_data = dataset[slice_index, :, :]                          logger.info(f"Extracted slice {slice_index} with shape: {slice_data.shape}")             return np.array(slice_data)                  except Exception as e:         logger.error(f"Failed to extract slice: {str(e)}")         raise HTTPException(status_code=500, detail=f"Failed to extract slice from .ims file: {str(e)}")
def analyze_standard_image(filepath: str) -> np.ndarray:     """Load standard image formats (PNG, JPG, TIFF)."""     image = Image.open(filepath)          # Resize if too large     max_dimension = 4000     if image.width > max_dimension or image.height > max_dimension:         ratio = min(max_dimension / image.width, max_dimension / image.height)         new_size = (int(image.width * ratio), int(image.height * ratio))         image = image.resize(new_size, Image.Resampling.LANCZOS)          if image.mode != 'RGB':         image = image.convert('RGB')          return np.array(image)
def analyze_vessels(image: np.ndarray, metadata: dict) -> dict:     """     Analyze vessels in the image.     Phase 1: Basic detection using intensity thresholding and morphology.     """     try:         logger.info(f"Starting vessel analysis on image with shape: {image.shape}")                  # Convert to grayscale if needed         if len(image.shape) == 3:             image_gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)         else:             image_gray = image                  # Normalize         if image_gray.max() > 1:             image_gray = image_gray.astype(float) / 255.0                  # Apply Gaussian blur         blurred = filters.gaussian(image_gray, sigma=1.5)                  # Threshold         threshold_value = filters.threshold_otsu(blurred)         binary_image = blurred > threshold_value                  # Morphological operations to clean up         binary_image = morphology.remove_small_objects(binary_image, min_size=20)         binary_image = morphology.remove_small_holes(binary_image, area_threshold=20)                  # Connected component analysis         labeled_image = measure.label(binary_image)         regions = measure.regionprops(labeled_image, intensity_image=image_gray)                  logger.info(f"Found {len(regions)} initial regions")                  # Filter for vessel-like structures         # Vessels are typically elongated (high eccentricity)         vessel_regions = []         min_area = 50         max_area = 10000         min_eccentricity = 0.7  # Elongated structures                  for region in regions:             if min_area < region.area < max_area and region.eccentricity > min_eccentricity:                 vessel_regions.append(region)                  vessel_count = len(vessel_regions)         logger.info(f"Detected {vessel_count} vessel-like structures")                  if vessel_count > 0:             # Calculate metrics             total_intensity = sum([r.mean_intensity for r in vessel_regions])             avg_intensity = total_intensity / vessel_count                          areas = [r.area for r in vessel_regions]             avg_vessel_area = np.mean(areas)                          # Calculate total vessel area             total_vessel_area = sum(areas)                          findings = []             findings.append(f"Detected {vessel_count} vessel-like structures")             findings.append(f"Average vessel area: {avg_vessel_area:.1f} pixels")             findings.append(f"Total vascular area: {total_vessel_area:.1f} pixels")                          return {                 "vessel_count": vessel_count,                 "average_intensity": float(avg_intensity),                 "summary": f"Analysis detected {vessel_count} vessel-like structures in this section.",                 "findings": findings,                 "confidence": min(0.8, vessel_count / 20),                 "measurements": {                     "avg_vessel_area_pixels": float(avg_vessel_area),                     "total_vascular_area": float(total_vessel_area),                     "vascular_density": float(total_vessel_area / (image_gray.shape[0] * image_gray.shape[1]))                 }             }         else:             return {                 "vessel_count": 0,                 "summary": "No vessels detected in this section.",                 "confidence": 0.0             }                  except Exception as e:         logger.error(f"Analysis failed: {str(e)}", exc_info=True)         raise HTTPException(status_code=500, detail=f"Analysis failed: {str(e)}")
@app.post("/analyze") async def analyze_endpoint(request: AnalysisRequest):     """     Main endpoint for image analysis.     Handles both .ims files and standard image formats.     """     temp_filepath = None          try:         logger.info(f"Received analysis request for URL: {request.image_url}")         logger.info(f"Metadata: {request.metadata}")                  # Download file         temp_filepath = download_file(request.image_url)                  # Check if it's an .ims file         if is_ims_file(temp_filepath):             logger.info("Detected .ims file format")                          # Extract metadata             ims_metadata = extract_ims_metadata(temp_filepath)                          # Extract a slice for analysis (Phase 1: analyze middle slice)             image = extract_slice_from_ims(temp_filepath)                          # Analyze             results = analyze_vessels(image, request.metadata)             results['file_format'] = 'ims'             results['ims_metadata'] = ims_metadata             results['analysis_note'] = 'Phase 1: Analyzed single slice from 3D volume'                      else:             logger.info("Processing as standard image format")             image = analyze_standard_image(temp_filepath)             results = analyze_vessels(image, request.metadata)             results['file_format'] = 'standard'                  logger.info("Analysis completed successfully")         return results              except HTTPException:         raise     except Exception as e:         logger.error(f"Unexpected error: {str(e)}", exc_info=True)         raise HTTPException(status_code=500, detail=f"Unexpected error: {str(e)}")     finally:         # Clean up temp file         if temp_filepath and os.path.exists(temp_filepath):             try:                 os.unlink(temp_filepath)                 logger.info("Cleaned up temporary file")             except Exception as e:                 logger.error(f"Failed to clean up temp file: {str(e)}")
@app.get("/") async def root():     return {         "message": "ADAPT-3D Vessel Analysis Service",         "version": "1.0.0 - Phase 1",         "capabilities": [             "Imaris .ims file support",             "Vessel detection and counting",             "Section-based analysis",             "Ready for Phase 2 enhancements"         ]     }
@app.get("/health") async def health():     return {"status": "healthy", "phase": "1 - Basic vessel detection"}
if __name__ == "__main__":     import uvicorn     port = int(os.getenv("PORT", 8000))     uvicorn.run(app, host="0.0.0.0", port=port)
